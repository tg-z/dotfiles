#!/usr/bin/env python3.8

"""
Copyright Â© 2019,2020  Lukas Himbert

sourcehut-client is free software:
you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 3 of the License.

sourcehut-client is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with sourcehut-client.
If not, see <https://www.gnu.org/licenses/>.


sourcehut-client assumes that the server is well-behaved.
All answers should return either a correct answer; an HTTP error code; or a JSON object with an "errors" entry.
It also trusts the server: Parts of the server response may be printed without any validation.
"""

import urllib.request
import urllib.error
import json
import sys
import os
import pathlib
import configparser
import argparse
import itertools
import platform
import ctypes
import errno


stdin = open(0, "rb")
stdout = open(1, "wb")


# Do not contact server, only prepare requests
pretend = bool(os.environ.get("SOURCEHUT_CLIENT_PRETEND", False))

# Read input raw / print raw output
raw = bool(os.environ.get("SOURCEHUT_CLIENT_RAW", False))


config_files = []
if "XDG_CONFIG_HOME" in os.environ.keys():
    config_files.append(pathlib.Path(os.environ["XDG_CONFIG_HOME"]) / "sourcehut-client.conf")
if "HOME" in os.environ.keys():
    config_files.append(pathlib.Path(os.environ["HOME"]) / ".sourcehut-client")


def unveil(path, prot):
    if platform.system() == "OpenBSD" and platform.version() >= "6.4":
        nullptr = ctypes.POINTER(ctypes.c_int)()
        if path is None:
            path = nullptr
        elif type(path) != bytes:
            path = bytes(path)
        if prot is None:
            prot = nullptr
        elif type(prot) != bytes:
            prot = bytes(prot)
        if ctypes.CDLL("libc.so").unveil(path, prot) != 0:
            raise RuntimeError(f'unveil("path", "prot") failed: {os.strerror(ctypes.get_errno())}')


# For safety when testing
def pledge(perm):
    if platform.system() == "OpenBSD" and platform.version() >= "6.4":
        ctypes.CDLL("libc.so").pledge(perm, b"")


def make_request(url, data=None, *, access_token, query=None, method=None):
    global pretend, raw
    headers = {"Authorization": f"token {access_token}"}
    if data is not None:
        headers["Content-Type"] = "application/json"
    if pretend:
        print(f"URL: {url}")
        if method is not None:
            print(f"Request method: {method}")
        print(f"Headers: {headers}")
        if data is not None:
            print(f"Data:")
            print(data)
        exit(1)
    try:
        if data is not None and type(data) != bytes:
            data = bytes(data, encoding="ascii")
        request = urllib.request.Request(url, headers=headers, data=data, method=method)
        resp = urllib.request.urlopen(request)
        response = resp.read()
        if not raw and resp.info().get_content_type() == "application/json" and response.strip():
            x = json.loads(response)
            if "errors" in x.keys():
                for err in x["errors"]:
                    print(f"sourcehut-client: {err['reason']}", file=sys.stderr)
                exit(1)
        return response
    except urllib.error.HTTPError as err:
        print(f"sourcehut-client: Request failed: {err.code}: {err.reason}", file=sys.stdout)
        exit(1)
    except urllib.error.URLError as err:
        print(f"sourcehut-client: Request failed: {err.reason}", file=sys.stdout)
        exit(1)
    except json.decoder.JSONDecodeError:
        print("sourcehut-client: Could not parse response as a JSON object.")
        exit(1)


def read_config():
    global config_files
    config = configparser.ConfigParser()
    if not config.read(config_files) or not config.sections():
        raise RuntimeError("No valid config file found.")
    cfg = {}
    for section in config.sections():
        cfg[section] = {}
        for key in ["access token", "username"]:
            try:
                cfg[section][key] = config.get(section, key)
            except configparser.NoOptionError:
                raise RuntimeError(f"Section {section} is missing key {key}.")
    return cfg


def read_file(fn):
    try:
        if fn:
            with open(fn, "r") as f:
                return f.read()
        else:
            return sys.stdin.read()
    except OSError as err:
        if fn:
            print(f"sourcehut-client: {fn}: {err}", file=sys.stderr)
        else:
            print(f"sourcehut-client: {err}", file=sys.stderr)
        exit(1)


def str_to_bool(s):
    if s.lower() == "true":
        return True
    elif s.lower() == "false":
        return False
    raise argparse.ArgumentTypeError(f"{s} is not a Boolean.")


def split_domain(domain):
    labels = domain.split(".")
    if len(labels) < 2:
        raise ValueError(f"'{domain}' is not a valid domain.")
    if any((len(label) == 0) for label in labels) or any(any((c.isdigit() or c == "-") for c in label) for label in labels):
        raise ValueError(f"'{domain} is not a valid domain.'")
    # Note: we do not check for total length of the domain name (should be <=253)
    return labels[0], ".".join(labels[1:])


def visibility_type(s):
    if s in ["public", "private", "unlisted"]:
        return s
    raise argparse.ArgumentTypeError(f"Invalid visibility {s}.")


def builds_submit(config, domain, argv):
    global raw
    parser = argparse.ArgumentParser(prog="sourcehut-client builds submit", description="Submit a new build job.")
    parser.add_argument("--note", nargs="?", metavar="note", help="Description of the build (default: empty)")
    parser.add_argument("--tags", action="append", metavar="tag", help="Tags (default: none)")
    parser.add_argument("--access:read", action="append", metavar="username", default=[config["username"]], help="Who has read access to the job? (default: %(default)s)")
    parser.add_argument("--access:write", action="append", metavar="username", help="Who has write access to the job?")
    parser.add_argument("--execute", metavar="true|false", type=str_to_bool, help="Immediately execute the job?")
    parser.add_argument("--secrets", metavar="true|false", type=str_to_bool, help="Provide secrets to the build?")
    parser.add_argument("manifest", nargs="?", type=pathlib.Path, help="Manifest file (default: standard input)")
    args = vars(parser.parse_args(argv))
    if args["manifest"]:
        unveil(bytes(args["manifest"]), b"r")
    unveil(None, None)
    url = f"https://builds.{domain}/api/jobs"
    if raw:
        data = sys.stdin.read(args["manifest"])
        stdout.write(make_request(url, access_token=config["access token"]))
    else:
        data = {key: val for (key, val) in args.items() if val is not None}
        data["manifest"] = read_file(args["manifest"])
        ret = make_request(url, data=json.dumps(data), access_token=config["access token"])
        print(f"Build submitted, build id: {json.loads(ret)['id']}")


def builds_info(config, domain, argv):
    unveil(None, None)
    global raw
    parser = argparse.ArgumentParser(prog="sourcehut-client builds info", description="Show information about a build job.")
    parser.add_argument("--note", action="store_const", const=True, help="Show note, if any.")
    parser.add_argument("--status", action="store_const", const=True, help="Show status information")
    parser.add_argument("--tags", action="store_const", const=True, help="Show tags, if any.")
    parser.add_argument("--tasks", action="store_const", const=True, help="Show task information")
    parser.add_argument("build_id", help="Build ID")
    args = vars(parser.parse_args(argv))
    url = f"https://builds.{domain}/api/jobs/{args['build_id']}"
    if raw:
        ret = make_request(url, access_token=config["access token"])
        stdout.write(ret)
        return
    ret = json.loads(make_request(url, access_token=config["access token"]))
    keys = ["note", "tags", "status", "tasks"]
    if not any(args[key] for key in keys):
        # If no specific information is requested, print everything
        for key in keys:
            args[key] = True
    if args["note"] and "note" in ret.keys():
        print(f"Note:")
        print(ret["note"])
    if args["tags"] and "tags" in ret.keys():
        print(f"Tags: {ret['tags']}")
    if args["status"]:
        print(f"Status: {ret['status']}")
    if args["tasks"]:
        if args["tasks"]:
            print("Tasks:")
        # Unfortunately, tasks are not returned in order, so we need to filter
        for task in itertools.chain(*[[t for t in ret["tasks"] if t["status"] == st] for st in ["success", "running", "failed", "pending"]]):
            if args["tasks"]:
                print(f" * {task['name']}: {task['status']}")


def builds_log(config, domain, argv):
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client builds manifest", description="Show log of an existing build job.")
    parser.add_argument("--setup-log", action="store_const", const=True, help="Show the setup log?")
    parser.add_argument("build_id", help="Build ID")
    parser.add_argument("task", nargs="?", metavar="task_id", help="Show log of a specific task")
    args = vars(parser.parse_args(argv))
    url = f"https://builds.{domain}/api/jobs/{args['build_id']}"
    ret = json.loads(make_request(url, access_token=config["access token"]))
    if args["setup_log"]:
        stdout.write(make_request(ret["setup_log"], access_token=config["access token"]))
    if args["task"] is None:
        for task in itertools.chain(*[[t for t in ret["tasks"] if t["status"] == st] for st in ["success", "running", "failed", "running"]]):
            stdout.write(make_request(task["log"], access_token=config["access token"]))
    for task in ret["tasks"]:
        if task["name"] == args["task"]:
            stdout.write(make_request(task["log"], access_token=config["access token"]))
            break
    else:
        if args["task"] is not None:
            print(f"Log for task {args['task']} not found.", file=sys.stderr)


def builds_manifest(config, domain, argv):
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client builds log", description="Retrieve the manifest of a previously submitted job.")
    parser.add_argument("build_id", type=int, help="Build ID")
    args = vars(parser.parse_args(argv))
    url = f"https://builds.{domain}/api/jobs/{args['build_id']}/manifest"
    ret = make_request(url, access_token=config["access token"])
    stdout.write(ret)


def builds_start(config, domain, argv):
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client builds start", description="Start a previously submitted job.")
    parser.add_argument("build_id", help="Build ID")
    args = vars(parser.parse_args(argv))
    url = f"https://builds.{domain}/api/jobs/{args['build_id']}/start"
    _ = make_request(url, access_token=config["access token"])
    # Should return an empty JSON object


def paste_list(config, domain, argv):
    unveil(None, None)
    global raw
    parser = argparse.ArgumentParser(prog="sourchut-client paste list", description="Retrieve a list of all your pastes")
    _ = parser.parse_args(argv)
    base_url = f"https://paste.{domain}/api/pastes"
    url = base_url
    pastes = []
    if raw:
        while True:
            _ret = make_request(url, access_token=config["access token"])
            stdout.write(_ret)
            ret = json.loads(_ret)
            if not ret["next"]:
                break
            url = f"{base_url}?start={ret['next']}"
        return
    while True:
        ret = json.loads(make_request(url, access_token=config["access token"]))
        pastes += ret["results"]
        if not ret["next"]:
            break
        url = f"{base_url}?start={ret['next']}"
    for paste in pastes:
        files = paste["files"]
        if not files or any(not f["filename"] for f in files):
            filestr = "file" if len(files) == 1 else "files"
            print(f"{paste['sha']} (created {paste['created']}, {len(files)} {filestr})")
        else:
            filenames = [f'"{f["filename"]}"' for f in paste["files"] if f["filename"]]
            if len(filenames) == 1:
                print(f"{paste['sha']} (created {paste['created']}, file {filenames[0]})")
            else:
                print(f"{paste['sha']} (created {paste['created']}, files {', '.join(filenames)})")


def paste_info(config, domain, argv):
    unveil(None, None)
    global raw
    parser = argparse.ArgumentParser(prog="sourcehut-client paste info", description="Show information about a paste")
    parser.add_argument("--user", action="store_const", const=True, help="Show user name")
    parser.add_argument("--visibility", action="store_const", const=True, help="Show paste visibility")
    parser.add_argument("--files", action="store_const", const=True, help="Show file information")
    parser.add_argument("paste_sha1", help="SHA-1 hash of the paste")
    args = vars(parser.parse_args(argv))
    keys = ["user", "visibility", "files"]
    if not any(args[key] for key in keys):
        # If no specific information is requested, print everything
        for key in keys:
            args[key] = True
    url = f"https://paste.{domain}/api/pastes/{args['paste_sha1']}"
    if raw:
        ret = make_request(url, access_token=config["access token"])
        stdout.write(ret)
        return
    ret = json.loads(make_request(url, access_token=config["access token"]))
    if args["user"]:
        print(f"User: {ret['user']['canonical_name']} (aka {ret['user']['name']})")
    if args["visibility"]:
        print(f"Visibility: {ret['visibility']}")
    if args["files"]:
        print("Files:")
        for file in ret["files"]:
            if file["filename"]:
                print(f"{file['blob_id']} {file['filename']}")
            else:
                print(file["blob_id"])


def paste_submit(config, domain, argv):
    global raw

    parser = argparse.ArgumentParser(prog="sourcehut-client paste submit", description="Submit a new paste")
    parser.add_argument("--visibility", metavar="public|private|unlisted", type=visibility_type, default="private", help="Paste visibility (default: %(default)s)")
    parser.add_argument("--upload-filenames", action="store_const", const=True, help="Upload file names? (default: do not upload any file names)")
    parser.add_argument("files", nargs="*", action="append", type=pathlib.Path, default=[], help="Names of files to upload (default: standard input)")
    args = vars(parser.parse_args(argv))
    for fn in args["files"][0]:
        unveil(bytes(fn), b"r")
    unveil(None, None)
    url = f"https://paste.{domain}/api/pastes"
    if raw:
        stdout.write(make_request(url, data=stdin.read(), access_token=config["access token"]))
        return
    if not args["files"][0]:
        files = [{"filename": None, "contents": sys.stdin.read()}]
    else:
        files = []
        for fn in args["files"][0]:
            try:
                with open(fn, "r") as f:
                    files.append({"filename": str(fn) if args["upload_filenames"] else None, "contents": f.read()})
            except OSError as err:
                print(f"Error reading file {fn}: {str(err)}")
                exit(1)
    if any(not f["contents"] for f in files):
        print("Empty paste content is not allowed.", file=sys.stderr)
        exit(1)
    data = {"visibility": args["visibility"], "files": files}
    ret = json.loads(make_request(url, data=json.dumps(data), access_token=config["access token"]))
    print(f"Paste submitted, paste id: {ret['sha']}")


def paste_show(config, domain, argv):
    global raw
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client paste show", description="Show a blob")
    parser.add_argument("blob_id", help="SHA1 hash of the blob")
    args = vars(parser.parse_args(argv))
    if raw:
        stdout.write(make_request(f"https://paste.{domain}/api/blobs/{args['blob_id']}", access_token=config["access token"]))
        return
    ret = json.loads(make_request(f"https://paste.{domain}/api/blobs/{args['blob_id']}", access_token=config["access token"]))
    print(ret["contents"], end="")


def git_create(config, domain, argv):
    global raw
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client git create", description="Create a new git repository")
    parser.add_argument("name", help="Name of the new repository")
    parser.add_argument("--visibility", metavar="public|private|unlisted", type=visibility_type, default="private", help="Git repository visibility (default: %(default)s)")
    parser.add_argument("--description", nargs="?", metavar="description", help="Description of the git repository (default: empty)")
    args = vars(parser.parse_args(argv))
    data = json.dumps({k: v for (k, v) in args.items() if v is not None})
    if raw:
        stdout.write(make_request(f"https://git.{domain}/api/repos", data=data, access_token=config["access token"]))
        return
    ret = json.loads(make_request(f"https://git.{domain}/api/repos", data=data, access_token=config["access token"]))
    print(f"Repository {ret['name']} created, id {ret['id']}. Visibility is {ret['visibility']}.")
    print(f"Repository URL: git@git.{domain}:{ret['owner']['canonical_name']}/{ret['name']}")


def git_show(config, domain, argv):
    global raw
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client git show", description="Show information about a git repository")
    parser.add_argument("name", help="Name of the repository")
    name = vars(parser.parse_args(argv))["name"]
    ret = make_request(f"https://git.{domain}/api/repos/{name}", access_token=config["access token"])
    if raw:
        stdout.write(ret)
        return
    ret = json.loads(ret)
    print(f"Repository id: {ret['id']}, created: {ret['created']}, subject: {ret['name']}")
    print(f"owner: {ret['owner']['canonical_name']} (aka {ret['owner']['name']})")
    print(f"name: {ret['name']}")
    print(f"visibility: {ret['visibility']}")
    print(f"description: {ret['description']}")


def git_update(config, domain, argv):
    global raw
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client git update", description="Update an existing git repository")
    parser.add_argument("old_name", help="Current name of the repository")
    parser.add_argument("--name", metavar="name", help="The new name of the repository")
    parser.add_argument("--visibility", metavar="public|private|unlisted", type=visibility_type, default=None, help="Git repository visibility")
    parser.add_argument("--description", default=None, metavar="description", help="Description of the git repository")
    args = vars(parser.parse_args(argv))
    old_name = args.pop("old_name")
    data = json.dumps({k: v for (k, v) in args.items() if v is not None})
    if raw:
        stdout.write(make_request(f"https://git.{domain}/api/repos/{old_name}", data=data, access_token=config["access token"], method="PUT"))
        return
    ret = json.loads(make_request(f"https://git.{domain}/api/repos/{old_name}", data=data, access_token=config["access token"], method="PUT"))
    print(f"Repository {old_name} updated.")
    if args.get("name", None) is not None:
        print(f"New name: {ret['name']}")
    if args.get("visibility", None) is not None:
        print(f"New visibility: {ret['visibility']}")
    if args.get("description", None) is not None:
        print(f"New description: {ret['description']}")


def git_destroy(config, domain, argv):
    global raw
    unveil(None, None)
    parser = argparse.ArgumentParser(prog="sourcehut-client git destroy", description="Destroy/delete an existing git repository")
    parser.add_argument("name", help="Name of the repository to be destroyed")
    args = vars(parser.parse_args(argv))
    ret = make_request(f"https://git.{domain}/api/repos/{args['name']}", access_token=config["access token"], method="DELETE")
    if raw:
        stdout.write(ret)
    else:
        print(f"Repository {args['name']} destroyed.")


commands = {"builds": {"submit": builds_submit, "info": builds_info, "log": builds_log, "manifest": builds_manifest, "start": builds_start}, "paste": {"list": paste_list, "info": paste_info, "submit": paste_submit, "show": paste_show}, "git": {"create": git_create, "show": git_show, "update": git_update, "destroy": git_destroy, "delete": git_destroy}}


def usage(str=None, err=True):
    global commands

    f = sys.stderr if err else sys.stdout
    if str:
        print(str, file=f)
    print("sourcehut-client: Available commands:", file=f)
    print(" * sourcehut-client help")
    for (subdomain, subcommands) in commands.items():
        for subcommand in subcommands.keys():
            print(f" * sourcehut-client {subdomain} {subcommand} ...", file=f)
    print("For help specific to a subcommand, call sourcehut-client <subdomain> <command> -h.", file=f)
    exit(2 if err else 0)


def dispatch(domain, subdomain, config, argv):
    global commands

    if domain not in config.keys():
        usage(f"sourcehut-client: No configuration found for domain {domain}.")

    if subdomain not in commands.keys():
        usage(f"sourcehut-client: Invalid subdomain {subdomain}.")

    if not argv:
        usage("sourcehut-client: Missing subcommand.")
    subcommand = argv[0]
    if subcommand not in commands[subdomain].keys():
        usage(f"sourcehut-client: Invalid subcommand {subcommand}.")

    commands[subdomain][subcommand](config[domain], domain, argv[1:])


if __name__ == "__main__":
    unveil(b"/usr", b"rx")
    unveil(bytes(pathlib.Path(__file__)), b"r")
    unveil(b"/etc/ssl", b"r")
    unveil(b"/etc/resolv.conf", b"r")
    unveil(b"/etc/hosts", b"r")
    for fn in config_files:
        unveil(bytes(fn), b"r")
    if pretend:
        pledge(b"stdio rpath unveil")
    else:
        pledge(b"stdio rpath unveil inet dns prot_exec")

    try:
        config = read_config()
    except RuntimeError as err:
        print(f"sourcehut-client: {err}", file=sys.stderr)
        exit(1)

    # Help?
    if len(sys.argv) < 2:
        usage("sourcehut-client: Missing subcommand or domain name.")
    if sys.argv[1] == "help":
        usage(err=False)

    # Is the first argument a domain name?
    try:
        subdomain, domain = split_domain(sys.argv[1])
        dispatch(domain, subdomain, config, sys.argv[2:])
        exit()
    except ValueError as err:
        pass

    # Is the first argument a (known) subdomain?
    subdomain = sys.argv[1]
    domain = list(config.keys())[0]
    dispatch(domain, subdomain, config, sys.argv[2:])
    exit()
